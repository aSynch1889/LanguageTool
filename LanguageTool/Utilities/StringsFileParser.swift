import Foundation

class StringsFileParser {
    /// 从 .strings 文件中提取键值对
    static func parseStringsFile(at path: String) -> Result<[String: String], Error> {
        do {
            let content = try String(contentsOfFile: path, encoding: .utf8)
            var result: [String: String] = [:]
            
            // 按行分割
            let lines = content.components(separatedBy: .newlines)
            
            for line in lines {
                let trimmed = line.trimmingCharacters(in: .whitespaces)
                // 跳过注释和空行
                if trimmed.isEmpty || trimmed.hasPrefix("//") || trimmed.hasPrefix("/*") {
                    continue
                }
                
                // 匹配 "key" = "value"; 格式
                if let regex = try? NSRegularExpression(pattern: "\"(.+?)\"\\s*=\\s*\"(.+?)\";") {
                    let nsRange = NSRange(trimmed.startIndex..<trimmed.endIndex, in: trimmed)
                    if let match = regex.firstMatch(in: trimmed, options: [], range: nsRange) {
                        if let keyRange = Range(match.range(at: 1), in: trimmed),
                           let valueRange = Range(match.range(at: 2), in: trimmed) {
                            let key = String(trimmed[keyRange])
                            let value = String(trimmed[valueRange])
                            result[key] = value
                        }
                    }
                }
            }
            
            return .success(result)
        } catch {
            return .failure(error)
        }
    }
    
    /// 生成 .strings 文件
    static func generateStringsFile(translations: [String: String], to path: String) -> Result<Void, Error> {
        var content = "/* Generated by Language Tool */\n\n"
        
        // 按键排序以保持一致性
        let sortedKeys = translations.keys.sorted()
        
        for key in sortedKeys {
            if let value = translations[key] {
                // 处理特殊字符
                let escapedKey = key.replacingOccurrences(of: "\"", with: "\\\"")
                let escapedValue = value.replacingOccurrences(of: "\"", with: "\\\"")
                content += "\"\(escapedKey)\" = \"\(escapedValue)\";\n"
            }
        }
        
        do {
            try content.write(to: URL(fileURLWithPath: path), atomically: true, encoding: .utf8)
            return .success(())
        } catch {
            return .failure(error)
        }
    }
    
    /// 将 .strings 格式转换为 .xcstrings 格式
    static func convertToXCStrings(translations: [String: String], languages: [String]) async -> Result<Data, Error> {
        var xcstringsDict: [String: Any] = [
            "version": "1.0",
            "sourceLanguage": "zh-Hans",
            "strings": [:] as [String: Any]
        ]
        
        var stringsDict: [String: Any] = [:]
        
        for (key, sourceValue) in translations {
            var localizationsDict: [String: Any] = [:]
            
            // 为每种语言创建翻译
            for language in languages {
                do {
                    // 使用 AI 服务翻译
                    let translation = try await AIService.shared.translate(text: sourceValue, to: language)
                    localizationsDict[language] = [
                        "stringUnit": [
                            "state": "translated",
                            "value": translation
                        ]
                    ]
                } catch {
                    print("翻译失败 [\(language)]: \(error.localizedDescription)")
                    localizationsDict[language] = [
                        "stringUnit": [
                            "state": "needs_review",
                            "value": ""
                        ]
                    ]
                }
            }
            
            stringsDict[key] = ["localizations": localizationsDict]
        }
        
        xcstringsDict["strings"] = stringsDict
        
        do {
            return .success(try JSONSerialization.data(withJSONObject: xcstringsDict, options: [.prettyPrinted, .sortedKeys]))
        } catch {
            return .failure(error)
        }
    }
    
    /// 处理 .strings 文件的转换
    static func processStringsFile(from inputPath: String, 
                                 to outputPath: String, 
                                 format: LocalizationFormat,
                                 languages: Set<Language>) async -> Result<String, Error> {
        do {
            let parseResult = parseStringsFile(at: inputPath)
            switch parseResult {
            case .success(let translations):
                if format == .xcstrings {
                    // 转换为 xcstrings
                    let xcstringsResult = await convertToXCStrings(
                        translations: translations,
                        languages: Array(languages).map { $0.code }
                    )
                    
                    switch xcstringsResult {
                    case .success(let data):
                        try data.write(to: URL(fileURLWithPath: outputPath))
                        return .success("Conversion successful!".localized)
                    case .failure(let error):
                        return .failure(error)
                    }
                } else {
                    print("开始生成 .strings 文件...")
                    let baseURL = URL(fileURLWithPath: outputPath)
                    
                    for language in languages {
                        print("处理语言: \(language.code)")
                        let langURL = baseURL.appendingPathComponent("\(language.code).lproj")
                        let stringsURL = langURL.appendingPathComponent("Localizable.strings")
                        
                        try FileManager.default.createDirectory(
                            at: langURL,
                            withIntermediateDirectories: true,
                            attributes: nil
                        )
                        
                        // 批量翻译优化
                        let values = Array(translations.values)
                        let keys = Array(translations.keys)
                        
                        print("开始批量翻译: \(language.code)")
                        let translatedValues = try await AIService.shared.batchTranslate(
                            texts: values,
                            to: language.code
                        )
                        
                        // 将翻译结果与键重新组合
                        var translatedDict: [String: String] = [:]
                        for (index, key) in keys.enumerated() {
                            if index < translatedValues.count {
                                translatedDict[key] = translatedValues[index]
                            }
                        }
                        
                        print("生成翻译文件: \(language.code)")
                        let result = generateStringsFile(
                            translations: translatedDict,
                            to: stringsURL.path
                        )
                        if case .failure(let error) = result {
                            throw error
                        }
                    }
                    return .success("Conversion successful!".localized)
                }
            case .failure(let error):
                return .failure(error)
            }
        } catch {
            return .failure(error)
        }
    }
} 
